#!/bin/sh

# Avoid long options, like --tmpdir for mktemp because they are not supported
# on UNIX and BSD.

# Locate relevant directories.
THIS_SCRIPT=$(basename "$0" .sh)
SCRIPT_DIR=$(dirname "$0") && [ "$SCRIPT_DIR" = "." ] && SCRIPT_DIR=$(pwd)
SCRIPT_FULL_NAME="$THIS_SCRIPT/$SCRIPT_DIR"
PARENT_DIR=$(dirname "$SCRIPT_DIR")
LIB_DIR="$PARENT_DIR"/lib
RESOURCES_DIR="$PARENT_DIR"/resources
CLASSES_DIR="$PARENT_DIR"/classes
MAIN_CLASS=com.alteredmechanism.notepad.Notepad
CLASS_PATH="$CLASSES_DIR:$RESOURCES_DIR"
OS=$(uname -s)

# $1 - Command basename
commandExists()
{
    # The "which" command does not return 1 on failure in OSX 10.4.11.
    # So "type" must be used instead.
	type "$1" > /dev/null
}

displayError()
{
    TITLE="ERROR in Program: $SCRIPT_FULL_NAME"
    if commandExists zenity
    then
    	zenity --text-info --title="$TITLE" --window-icon=error --text="$*"
    elif commandExists kdialog 
    then
    	kdialog --title "$TITLE" --text "$*"
    elif commandExists Xdialog
    then
    	Xdialog --title="$TITLE" --screen-center --no-cancel --text "$*"
    elif commandExists xmessage
    then
    	# xmessage seems to automatically handle setting the width and height
    	# properly. It's really the best of these programs... :-)
    	xmessage -fg red -center -default okay -title "$TITLE" $*
    elif commandExists xterm
    then
        xterm -title "$TITLE" -e "echo $* ; echo Press Enter to continue. ; read LINE"
    elif [ "$(uname -s)" = "Darwin" ]
    then
    	# Tell the background process SystemUIServer to display the dialog.
	osascript -e 'tell application "SystemUIServer"
		display dialog "$*"
	end
	activate application (path to frontmost application as text)'
    else
        echo $TITLE
        cat "$*"
    fi
}

displayErrorFile()
{
    PROGRAM_NAME=$1
    ERROR_FILE=$2
    TITLE="ERROR in Program: $PROGRAM_NAME"
    WIDTH=900
    HEIGHT=480
    if commandExists zenity
    then
    	zenity --text-info --height=$HEIGHT --width=$WIDTH --title="$TITLE" \
    		--no-wrap --window-icon=error --filename="$ERROR_FILE"
    elif commandExists kdialog 
    then
    	kdialog --title "$TITLE" --textbox "$ERROR_FILE" \
    		--geometry $WIDTHx$HEIGHT
    elif commandExists Xdialog
    then
    	Xdialog --title="$TITLE" --screen-center --no-cancel \
    		--textbox "$ERROR_FILE" $HEIGHT $WIDTH
    elif commandExists xmessage
    then
    	# xmessage seems to automatically handle setting the width and height
    	# properly. It's really the best of these programs... :-)
    	xmessage -fg red -center -default okay -title "$TITLE" \
    		-file "$ERROR_FILE"
    elif commandExists xterm
    then
        xterm -title "$TITLE" \
            -e "cat $ERROR_FILE ; echo Press Enter to continue. ; read LINE"
    elif [ "$(uname -s)" = "Darwin" ]
    then
        MESSAGE=$(cat "$ERROR_FILE")
    	# Tell the background process SystemUIServer to display the dialog.
	osascript -e 'tell application "SystemUIServer"
		display dialog "$MESSAGE"
	end
	activate application (path to frontmost application as text)'
    else
        echo $TITLE
        cat "$ERROR_FILE"
    fi
}

# Setup fifo so that we can use 'tee' to send stderr to both the console
# and a file. The file will be used to display a window on the desktop
# with the errors it contains after the program exits. This will allow
# a user without visibility to the stderr output in a terminal to see
# any errors.
duplicateStdErr()
{
    TEMP_DIR=${TMPDIR:-/tmp}
    # The mktemp command is the way it is for compatibility with BSD systems
    # like Mac OS X 10.4.11. Don't change without testing.
    STDERR_FILE=$(mktemp "$TEMP_DIR"/"$THIS_SCRIPT".stderr.XXXXXXXXXX)
    STDERR_FIFO=$(mktemp -u "$TEMP_DIR"/"$THIS_SCRIPT".fifo.XXXXXXXXXX)
    mkfifo "$STDERR_FIFO"
    trap 'rm "$STDERR_FIFO" "$STDERR_FILE"' EXIT
    tee -a "$STDERR_FILE" < "$STDERR_FIFO" >&2 &
}

handleOutOfMemoryError()
{
    displayError An OutOfMemoryError has occurred. The application will be closed.
    exit 1
}

# Set the icon for Mac.
if [ "$OS" = 'Darwin' ]
then
	MAC_DOCK_ICON=-Xdock:icon="$RESOURCES_DIR"/icons/notepad-64x64.png
else
	unset MAC_ICON
fi

duplicateStdErr

# Run
if [ -z "$MAC_DOCK_ICON" ]
then
    # -Xshare:on is critical but usually done by default...
    java -XX:OnOutOfMemoryError="handleOutOfMemoryError" -classpath "$CLASS_PATH" "$MAIN_CLASS" "$@" 2> "$STDERR_FIFO"
    JAVA_EXIT_CODE=$?
else
    java -XX:OnOutOfMemoryError="handleOutOfMemoryError" "$MAC_DOCK_ICON" -classpath "$CLASS_PATH" "$MAIN_CLASS" "$@" 2> "$STDERR_FIFO"
    JAVA_EXIT_CODE=$?
fi

# Check for non-empty file
if [ -s "$STDERR_FILE" ]
then
	displayErrorFile "$0" "$STDERR_FILE"
elif [ $JAVA_EXIT_CODE -ne 0 ]
then
	cat > "$STDERR_FILE" <<-EOF
The program returned an exit code of $JAVA_EXIT_CODE, which is a failure code.
But it did not produce an error message on the standard error stream.
It is possible that it wrote an error message to the standard output stream,
but that has not been captured. Try running the program from the command line
to get the error message. This is the command to run:
$0 "$@"
EOF
	displayErrorFile "$0" "$STDERR_FILE"
fi